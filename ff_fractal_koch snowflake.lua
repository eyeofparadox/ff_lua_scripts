-- A script for Filter Forge that generates a Koch Snowflake:
name = "Koch Snowflake"
--[[
	Koch Snowflake - (2D) The Koch Snowflake, a fractal named after the Swedish mathematician Helge von Koch, is a fractal generated by iteratively adding smaller and smaller triangles to the sides of an equilateral triangle (or recursively subdividing an equilateral triangle into smaller equilateral triangles, and replacing the middle third of each side with two sides that form an equilateral triangle). The resulting shape has an infinite perimeter, but a finite area. 
	Image: https://commons.wikimedia.org/wiki/File:KochFlake.svg, https://upload.wikimedia.org/wikipedia/commons/0/05/Koch_flake_6.png
	Programs that can generate the Koch Snowflake include Processing, MATLAB, Python, Fractal, Fractint, XaoS, Apophysis, Fractal eXtreme, Ultra Fractal and Mandelbulber. 
]]--
-- Set up the input parameters
parameters = 
{
    {name = "Iterations", control = "slider", min = 1, max = 6, default = 4},
    {name = "Size", control = "slider", min = 10, max = 500, default = 200},
    {name = "Thickness", control = "slider", min = 1, max = 10, default = 3},
}

-- Define the main function that generates the snowflake
function run(steps, size, thickness)
    -- Calculate the size of each segment of the snowflake
    local segment_size = size / 3
    
    -- Create the starting point of the snowflake
    local start_point = {x = size / 2, y = size - 5}
    
    -- Create the initial line segment of the snowflake
    local line = {start_point, {x = start_point.x + segment_size, y = start_point.y}}
    
    -- Iterate through the specified number of steps
    for i = 1, steps do
        -- Create a new set of line segments for this iteration
        local new_lines = {}
        
        -- Iterate through each segment in the current set of line segments
        for j = 1, #line do
            -- Calculate the points that make up the Koch curve for this segment
            local a = line[j]
            local b = line[j + 1] or line[1]
            local dx = (b.x - a.x) / 3
            local dy = (b.y - a.y) / 3
            local p1 = {x = a.x + dx, y = a.y + dy}
            local p2 = {x = b.x - dx, y = b.y - dy}
            local angle = math.atan2(b.y - a.y, b.x - a.x) + math.pi / 3
            local dx = segment_size * math.cos(angle)
            local dy = segment_size * math.sin(angle)
            local p3 = {x = p1.x + dx, y = p1.y + dy}
            
            -- Add the new line segments to the list
            table.insert(new_lines, {a, p1})
            table.insert(new_lines, {p1, p3})
            table.insert(new_lines, {p3, p2})
            table.insert(new_lines, {p2, b})
        end
        
        -- Update the current set of line segments to the new set
        line = new_lines
    end
    
    -- Draw the final set of line segments as a shape
    local shape = Shape()
    for i = 1, #line do
        shape:add_line(line[i][1].x, line[i][1].y, line[i][2].x, line[i][2].y, thickness)
    end
    
    -- Return the final shape
    return shape
end
-- To use this script, simply copy and paste it into a new Script component in Filter Forge. Then, you can adjust the parameters to generate different sizes and iterations of the Koch Snowflake.


-- An updated version of the script for generating a Koch Snowflake in Filter Forge, which includes a random seed parameter:
-- Koch Snowflake Generator with Random Seed Parameter
-- By ChatGPT

function koch_snowflake(size, iterations, seed)
    -- Set random seed
    math.randomseed(seed)
    
    -- Initialize variables
    local scale = 3^(0.5) / 6
    local angle = 60
    
    -- Create initial triangle
    local points = {
        {x = 0, y = 0},
        {x = size, y = 0},
        {x = size / 2, y = size * scale},
    }
    
    -- Perform iterations
    for i = 1, iterations do
        local new_points = {}
        for j = 1, #points do
            local p1 = points[j]
            local p2 = points[j + 1] or points[1]
            local dx = p2.x - p1.x
            local dy = p2.y - p1.y
            local dist = math.sqrt(dx^2 + dy^2)
            local unit_dx = dx / dist
            local unit_dy = dy / dist
            local mid_x = (p1.x + p2.x) / 2
            local mid_y = (p1.y + p2.y) / 2
            local angle_rad = math.rad(angle)
            local offset_x = unit_dx * math.cos(angle_rad) - unit_dy * math.sin(angle_rad)
            local offset_y = unit_dx * math.sin(angle_rad) + unit_dy * math.cos(angle_rad)
            local new_x = mid_x + offset_x * dist / 3
            local new_y = mid_y + offset_y * dist / 3
            table.insert(new_points, p1)
            table.insert(new_points, {x = new_x, y = new_y})
        end
        points = new_points
    end
    
    -- Create image from points
    local image = make_empty_image(size, size, "RGBA")
    local brush = make_brush(1, "Circle")
    for i = 1, #points do
        local p1 = points[i]
        local p2 = points[i + 1] or points[1]
        draw_line(image, p1.x, p1.y, p2.x, p2.y, brush, {0, 0, 0, 255})
    end
    
    return image
end

-- Define parameters
define_parameter("size", "Size", 400, 100, 800, 1)
define_parameter("iterations", "Iterations", 4, 1, 6, 1)
define_parameter("seed", "Random Seed", 1234, 1, 1000000, 1)

-- Generate Koch Snowflake
local image = koch_snowflake(size, iterations, seed)

-- Set output image
set_image("Output", image)
	-- In this version of the script, the seed parameter is defined using define_parameter(), with a default value of 1234 and a range from 1 to 1000000. The math.randomseed() function is used to set the random seed based on the value of the seed parameter, which ensures that the same snowflake is generated for a given seed value.

