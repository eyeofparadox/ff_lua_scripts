-- rotational shadow map v.0.1.20230602:02:00
	-- this version works (as of note creation)
	local sqrt, min, max, rad, pi = math.sqrt, math.min, math.max, math.rad, math.pi
	local sin, cos, tan, asin, acos, atan2 = math.sin, math.cos, math.tan, math.asin, math.acos, math.atan2

function prepare()
	-- inputs and precalculation.
	m_aspect = OUTPUT_HEIGHT / OUTPUT_WIDTH * 2
	s_aspect = OUTPUT_WIDTH / OUTPUT_HEIGHT
	tilt_1 = rad(get_angle_input(TILT_1)) -- x axis
	rotation_1 = rad(1 - get_angle_input(ROTATION_1)) -- y axis, facing 0 meridian * s_aspect
	roll_1 = rad(1 - get_angle_input(ROLL_1)) -- z axis
	cx_1, sx_1, cy_1, sy_1, cz_1, sz_1 = get_cos_sin(tilt_1, rotation_1, roll_1)
	hdr = true
end;

function get_sample(x, y)
	local ir, ig, ib, ia = get_sample_map(x, y, SOURCE)
	local gs = 0.2126 * ir + 0.7152 * ig + 0.0722 * ib
	-- image generation
	local x = x - 0.5
	local y = y * pi
	x = x * m_aspect * pi
	local nx = cos(x) * sin(y)
	local ny = sin(x) * sin(y)
	local nz = cos(y)
	local ax1, ax2 = (nx * cx_1) + (ny * sx_1), (nx * sx_1) - (ny * cx_1)
	local ay1, ay2 = (ax1 * cy_1) - (cos(y) * sy_1), (ax1 * sy_1) + (cos(y) * cy_1)
	local az1, az2 = (ax2 * cz_1) + (ay2 * sz_1), (ax2 * sz_1) - (ay2 * cz_1)
	nx = atan2(az1, ay1) * 0.159155 + 0.5
	ny = acos(az2) * 0.16 * 2
	if s_aspect == 2 then nx = nx * 2 - 1 end
	sr, sg, sb, sa = get_shadowmap(nx, ny)
	r, g, b, a = blend_linear_dodge(gs, gs, gs, 1, 0.5, 0.5, 0.5, 1, 1, hdr)
	r, g, b, a = blend_multiply(r, g, b, a, sr, sg, sb, sa, 1, hdr)
	r, g, b, a = blend_hard_light(ir, ig, ib, ia, r, g, b, a, 1)
	return  r, g, b, a
end;

function get_shadowmap(x, y)
	local x = x * m_aspect * pi
	local y = y * pi
	local nx = cos(x) * sin(y)
	local ny = sin(x) * sin(y)
	local nz = cos(y)
	nx, ny, nz = nx * 0.5 + 0.5, ny * 0.5 + 0.5, nz * 0.5 + 0.5
	r = get_sample_curve(nx, ny, nz, PROFILE)
	return r, r, r, 1
end;
	-- return nx, ny, nz, 1
	-- return nx, nx, nx, 1

function cos_sin(angle)
	local cos_angle, sin_angle = cos(angle), sin(angle)
	return cos_angle, sin_angle
end;

function get_cos_sin(rotation, tilt, roll)
	local rotation, tilt, roll = rotation, tilt, roll
	local cy, sy = cos_sin(rotation)
	local cx, sx = cos_sin(tilt)
	local cz, sz = cos_sin(roll)
	return cy, sy, cx, sx, cz, sz
end;
