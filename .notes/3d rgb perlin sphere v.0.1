-- 3d rgb noise on a sphere v.0.1
function prepare()
--	constants
	ROUGHNESS_THRESHOLD = 0.00001
	REMAINDER_THRESHOLD = 0.00001

--	input values
	details = get_slider_input(DETAILS) * 10 
	NOISE_SIZE = get_slider_input(SCALE)
	
	-- tilt & rotation precalc
	radius = get_slider_input(RADIUS)

	angle = get_angle_input(ROTATION)
	angle_r = math.rad(angle)
	angle_g = math.rad(angle + 240)
	angle_b = math.rad(angle + 120)
	cosa_r = math.cos(angle_r)
	sina_r = math.sin(angle_r)
	cosa_g = math.cos(angle_g)
	sina_g = math.sin(angle_g)
	cosa_b = math.cos(angle_b)
	sina_b = math.sin(angle_b)

	tilt = math.rad(get_angle_input(TILT))
	cosa_t = math.cos(tilt)
	sina_t = math.sin(tilt)

	p = {}
	math.randomseed(get_intslider_input(SEED))
	for i=0,255 do
		p[i] = math.random(255)
		p[256+i] = p[i]
	end

	if (get_checkbox_input(RGB_OR_V)) then
		vrgb = true
	else
		vrgb = false
	end
end;


function get_sample(x, y)
	local contrast = (get_sample_grayscale(x, y, CONTRAST) * 2) - 1
	local factor = (259 * (contrast + 1)) / (1 * (259 - contrast))
	local na = 0

	-- noise generation
	OCTAVES_COUNT = math.floor(details)

	local remainder = details - OCTAVES_COUNT
	if (remainder > REMAINDER_THRESHOLD) then
		OCTAVES_COUNT = OCTAVES_COUNT + 1
	end

	local roughness = ROUGHNESS_THRESHOLD + 
		(get_sample_grayscale(x, y, ROUGHNESS) * 0.5 + 0.5) * (1.0 - ROUGHNESS_THRESHOLD)
	
	OCTAVES = {}
	local cell_size = (0.01 + NOISE_SIZE * 0.99) * 10
	local scale = roughness
	local octave_index
	for octave_index = 1, OCTAVES_COUNT do
		if (scale < ROUGHNESS_THRESHOLD) then
			OCTAVES_COUNT = octave_index - 1
			break
		end
		OCTAVES[octave_index] = {cell_size, scale}
		cell_size = cell_size * 2.0
		scale = scale * roughness
	end
	
	if (remainder >= 0.001) then
		OCTAVES[OCTAVES_COUNT][2] = OCTAVES[OCTAVES_COUNT][2] * remainder
	end

	NORM_FACTOR = 0
	for octave_index = 1, OCTAVES_COUNT do
		NORM_FACTOR = NORM_FACTOR + OCTAVES[octave_index][2]-- ^ 2
	end
	
	-- sphere generation and manipulation
	-- origin to center
	local px = (x*2.0) - 1.0
	local py = (y*2.0) - 1.0
	-- set sphere radius (max == screen height)
	px = px/radius
	py = py/radius
	-- check radius and clip
	local len = math.sqrt((px*px)+(py*py))
	if len > 1.0 then return 0,0,0,0 end

	local z = -math.sqrt(1.0 - ((px*px)+(py*py)))

	-- mapping for rotation and tilt
	local tz = (cosa_t * z) - (sina_t * py)
	local ty = (sina_t * z) + (cosa_t * py)
	z = tz
	py = ty

	local tx_r = (cosa_r * px) - (sina_r * z)
	local tz_r = (sina_r * px) + (cosa_r * z)
	px_r = tx_r
	z_r = tz_r

	-- distortion by neighboring channel noise, modified by grayscale input (power)
	local dx, dy, dz, da = get_sample_map(x, y, DISTORTION) -- * 2
	-- noise or gradient calculations can be assigned to variables here 
	local nr, ng, nb, na = 0, 0, 0, 0
	local dr, dg, db, da = 0, 0, 0, 0
	local octave_index 
	for octave_index = 1, OCTAVES_COUNT do
		local size = OCTAVES[octave_index][1]
		local opacity = OCTAVES[octave_index][2]
		local noise_z = octave_index
		dr = dr + (opacity * noise(px*size,py*size,((z*size)+noise_z)+OUTPUT_WIDTH * -1)) * dx
		dg = dg + (opacity * noise(px*size,py*size,((z*size)+noise_z)+OUTPUT_WIDTH * -2)) * dy
		db = db + (opacity * noise(px*size,py*size,((z*size)+noise_z)+OUTPUT_WIDTH * -3)) * dz
		da = da + (opacity * noise(px*size,py*size,((z*size)+noise_z)+OUTPUT_WIDTH * -4)) * da
		nr = nr + (opacity * noise(px*size+dr,py*size+dg,((z*size)+noise_z+db)+OUTPUT_WIDTH))
		ng = ng + (opacity * noise(px*size+dg,py*size+db,((z*size)+noise_z+dr)+OUTPUT_WIDTH * 2))
		nb = nb + (opacity * noise(px*size+db,py*size+dr,((z*size)+noise_z+dg)+OUTPUT_WIDTH *3))
		na = na + (opacity * noise(px*size+da,py*size+da,((z*size)+noise_z+da)+OUTPUT_WIDTH *4))
	end
	dr = (dr+1.0)/2.0
	dg = (dg+1.0)/2.0
	db = (db+1.0)/2.0
	da = (da+1.0)/2.0
	nr = (nr+1.0)/2.0
	ng = (ng+1.0)/2.0
	nb = (nb+1.0)/2.0
	na = (na+1.0)/2.0

	na = nr
	nr = truncate(factor * (nr - 0.5) + 0.5)
	ng = truncate(factor * (ng - 0.5) + 0.5)
	nb = truncate(factor * (nb- 0.5) + 0.5)
	na = truncate(factor * (na - 0.5) + 0.5)

	nr = get_sample_curve(x,y,nr,PROFILE)
	ng = get_sample_curve(x,y,ng,PROFILE)
	nb = get_sample_curve(x,y,nb,PROFILE)
	na = get_sample_curve(x,y,na,PROFILE)

	-- return nr,ng,nb,1
	-- return nr,nr,nr,1
	-- return ng,ng,ng,1
	-- return nb,nb,nb,1
	-- return px/2+.5,0,0,1
	if vrgb then
		return na,na,na,a 
	else
		return nr,ng,nb,1 
	end
end;

function noise(x, y, z) 
  local x = math.floor(x) % 256
  local y = math.floor(y) % 256
  local z = math.floor(z) % 256
  x = x - math.floor(x)
  y = y - math.floor(y)
  z = z - math.floor(z)
  local u = fade(x)
  local v = fade(y)
  local w = fade(z)

  a   = p[x  ]+y
  aa  = p[a]+z
  ab  = p[a+1]+z
  b   = p[x+1]+y
  ba  = p[b]+z
  bb  = p[b+1]+z

  return lerp(w, lerp(v, lerp(u, grad(p[aa  ], x  , y  , z   ), 
                                 grad(p[ba  ], x-1, y  , z   )), 
                         lerp(u, grad(p[ab  ], x  , y-1, z   ), 
                                 grad(p[bb  ], x-1, y-1, z   ))),
                 lerp(v, lerp(u, grad(p[aa+1], x  , y  , z-1 ),  
                                 grad(p[ba+1], x-1, y  , z-1 )),
                         lerp(u, grad(p[ab+1], x  , y-1, z-1 ),
                                 grad(p[bb+1], x-1, y-1, z-1 )))
  )
end;


function fade(t)
  return t * t * t * (t * (t * 6 - 15) + 10)
end;


function lerp(t,a,b)
  return a + t * (b - a)
end;


function grad(hash,x,y,z)
  local h = hash % 16
  local u 
  local v 

  if (h<8) then u = x else u = y end
  if (h<4) then v = y elseif (h==12 or h==14) then v=x else v=z end
  local r

  if ((h%2) == 0) then r=u else r=-u end
  if ((h%4) == 0) then r=r+v else r=r-v end
	return r
end;


function truncate(value)
	if value <= 0 then value = 0 end
	if value >= 1 then value = 1 end
	return value
end;